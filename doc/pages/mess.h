namespace vaca {

/**

@page page_mess MESS Architecture

@li @ref page_mess_intro
@li @ref page_mess_win32
@li @ref page_mess_messages
@li @ref page_mess_events
@li @ref page_mess_signals


@section page_mess_intro Introduction

MESS stands for Message-Event-Signal/Slot:

@li @c Message: a message produced by the operating system (e.g. @msdn{WM_KEYUP}).
@li @c Event: a virtual method to control the message (e.g. Widget#onKeyUp)
@li @c Signal: a variable member which anybody can connect their callbacks (e.g. Widget#KeyUp)
@li @c Slot: an instance of @link Slot0 Slot@endlink that wraps functions,
    function objects (@em functors), or classes' methods.
    They are automatically created/connected to signals when you
    use functions like @link Signal#connect Signal::connect@endlink.

Basically when a @em message came from the operating system, it means
that the user inputs a value or is waiting for an output. The @em message
produces an @em event that is received by a specific Widget.
Default implementations of the events fire a @em signal
related to that event.

Signals can be intercepted by anyone. Each connection to a signal is
called a @link Slot0 slot@endlink. You shouldn't worry about slots,
they are created and destroyed automatically, you just use Signal#connect.

In each Vaca's widget there are defined methods to handle @em events
inside the widget, and there are @em signals for events that should be
intercepted by the parent widget. There should be a signal for each
event that makes sense to be intercepted by the parent (or anyone that
is not the widget itself).

One interesting thing about signals is that they are public members of
classes, and their names begin with a capital letter (like
Button#Action). For more information about this see @ref page_tn_004.
    

@section page_mess_win32 General Behavior on Win32

@li A @em message is received from Windows (e.g. @msdn{WM_PAINT}).
@li A global WndProc (Widget#getGlobalWndProc)
    extracts the @msdn{GWL_USERDATA} from the @msdn{HWND} that received the message. Note:
    New versions of Vaca stores the Widget pointer in the "VacaAtom" property, see
    Widget#fromHandle for more information.
@li In the @msdn{GWL_USERDATA} is located a pointer to a @ref Widget.
@li This instance is used to call the Widget#wndProc
    method to process the message.
@li Depending of the received message by Widget#wndProc, it calls
    another method (an @em event) that can be overridden
    (like Widget#onPaint, Widget#onResize, etc.).
@li Finally the event triggers its corresponding signal.

@image html MESS.png


@section page_mess_messages Messages

All messages are generated by the operating system through user
interation. Each thread that has widgets has a queue of messages too.
You are responsible to process each message and flush the queue.
Vaca gives you the Application class to manage the main thread of
execution (Application is derived from Thread).

Your program should start like this:
@code
int VACA_MAIN()
{
  Application app;
  ...
  app.run();
}
@endcode

Just one instance of Application can exist in your whole program.
The Application#run method start a loop to process messages
from the queue. You could use the next code if you want:
@warning In this case the Application#main method is not called.
@code
int VACA_MAIN()
{
  Application app;
  ...
  app.doMessageLoop();
}
@endcode
 
The Application#doMessageLoop just get messages from
the queue (Thread#getMessage) and process them (Thread#processMessage)
until there are not more visible @link Frame Frames@endlink.

@win32 If a @msdn{WM_QUIT} message is received, the queue
       processing is terminated too.
@endwin32

@see Thread, Thread::Message, Thread#doMessageLoop


@section page_mess_events Events


@section page_mess_signals Signals/Slots

*/

}
